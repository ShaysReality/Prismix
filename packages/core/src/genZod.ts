import type { DMMF } from '@prisma/internals';
import { mapScalar } from './mapping';

export function emitZod(models: DMMF.Model[], enums: DMMF.DatamodelEnum[]) {
  const chunks: string[] = [];
  chunks.push(`// Auto-generated by Prismix\nimport { z } from 'zod';\n`);

  // Enums
  for (const e of enums) {
    const values = e.values.map(v => `'${v.name}'`).join(', ');
    chunks.push(`export const ${e.name} = z.enum([${values}]);`);
    chunks.push(`export type ${e.name} = z.infer<typeof ${e.name}>;\n`);
  }

  // Models
  for (const m of models) {
    const lines: string[] = [];
    for (const f of m.fields) {
      if (f.kind === 'enum') {
        const isList = f.isList;
        const opt = f.isRequired ? '' : '.optional()';
        let z = `${f.type}`;
        z = isList ? `z.array(${z})` : z;
        lines.push(`${JSON.stringify(f.name)}: ${z}${opt},`);
      } else if (f.kind === 'scalar') {
        lines.push(`${JSON.stringify(f.name)}: ${mapScalar(f)},`);
      } else if (f.kind === 'object') {
        const base = 'z.any()';
        const z = f.isList ? `z.array(${base})` : base;
        const opt = f.isRequired ? '' : '.optional()';
        lines.push(`${JSON.stringify(f.name)}: ${z}${opt},`);
      }
    }
    chunks.push(`export const ${m.name}Schema = z.object({\n  ${lines.join('\n  ')}\n});`);
    chunks.push(`export type ${m.name} = z.infer<typeof ${m.name}Schema>;\n`);
  }

  chunks.push('export const models = { ' + models.map(m => m.name + 'Schema').join(', ') + ' };');
  return chunks.join('\n');
}
